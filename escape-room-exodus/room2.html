<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>×—×“×¨ 2 â€” ×§×¨×™×¢×ª ×™× ×¡×•×£</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Sea scene styles */
    .sea-scene { margin: 15px 0; border-radius: 12px; overflow: hidden; border: 1px solid rgba(0,191,255,0.2); }
    .sea-scene canvas { width: 100%; display: block; }
    .sea-label { text-align: center; padding: 8px; font-size: 0.8rem; color: rgba(0,191,255,0.5); background: rgba(0,20,60,0.5); }

    /* Fragment grid */
    .fragments-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin: 10px 0; }
    .scroll-fragment {
      background: rgba(0,50,100,0.15); border: 2px solid rgba(0,191,255,0.2);
      border-radius: 12px; padding: 16px 8px; cursor: pointer; text-align: center;
      transition: all 0.3s; min-height: 80px;
      display: flex; align-items: center; justify-content: center;
      font-family: 'Frank Ruhl Libre', serif; font-size: 0.9rem; color: rgba(255,255,255,0.7);
      position: relative;
    }
    .scroll-fragment:hover:not(.picked) { background: rgba(0,100,200,0.2); border-color: rgba(0,191,255,0.4); transform: translateY(-3px); }
    .scroll-fragment.picked { pointer-events: none; }
    .scroll-fragment.correct-pick {
      border-color: rgba(255,215,0,0.5) !important; background: rgba(50,50,0,0.2) !important;
      color: #ffd700; box-shadow: 0 0 15px rgba(255,215,0,0.15);
    }
    .scroll-fragment.wrong-pick {
      border-color: rgba(255,50,50,0.5) !important; background: rgba(100,0,0,0.2) !important;
      opacity: 0.3; color: #ff6666;
      animation: fragmentDie 0.6s ease-out;
    }
    @keyframes fragmentDie {
      0% { transform: scale(1); } 20% { transform: scale(1.1); box-shadow: 0 0 25px rgba(255,0,0,0.5); }
      40% { transform: scale(0.95); } 100% { transform: scale(1); }
    }
    .scroll-fragment.wrong-pick::after { content: '\274C'; position: absolute; top: 3px; left: 3px; font-size: 0.8rem; }
    .scroll-fragment.correct-pick::after { content: '\2705'; position: absolute; top: 3px; left: 3px; font-size: 0.8rem; }

    /* Verse assembly */
    .verse-assembly {
      text-align: center; margin: 15px 0; padding: 15px;
      background: rgba(0,30,60,0.3); border-radius: 10px;
      font-family: 'Frank Ruhl Libre', serif; font-size: 1.1rem;
      color: rgba(255,255,255,0.4); direction: rtl;
      border: 1px solid rgba(0,100,200,0.2);
    }
    .fragment-slot { margin: 0 3px; transition: all 0.3s; }
    .fragment-slot.filled { color: #ffd700; font-weight: bold; text-shadow: 0 0 10px rgba(255,215,0,0.3); }
    .fragment-slot.highlight { font-size: 1.4rem; color: #ff8844; text-shadow: 0 0 15px rgba(255,136,68,0.5); }

    /* Lives bar */
    .lives-bar { display: flex; justify-content: center; align-items: center; gap: 8px; margin: 10px 0; }
    .lives-bar .heart { font-size: 1.5rem; transition: all 0.4s; filter: drop-shadow(0 0 5px rgba(255,50,50,0.5)); }
    .lives-bar .heart.lost { filter: grayscale(1) opacity(0.2); transform: scale(0.7); }
    .lives-bar .heart.breaking { animation: heartBreak 0.5s ease-out; }
    @keyframes heartBreak { 0% { transform: scale(1); } 30% { transform: scale(1.4); filter: drop-shadow(0 0 15px rgba(255,0,0,0.8)); } 100% { transform: scale(0.7); filter: grayscale(1) opacity(0.2); } }
    .lives-label { font-size: 0.8rem; color: rgba(0,150,255,0.6); font-family: 'Secular One', sans-serif; }

    /* Penalty overlay */
    .penalty-overlay {
      position: fixed; inset: 0; z-index: 9999; background: rgba(0,0,0,0.85);
      display: none; flex-direction: column; align-items: center; justify-content: center;
    }
    .penalty-overlay.active { display: flex; animation: fadeIn 0.3s; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .penalty-icon { font-size: 4rem; margin-bottom: 10px; animation: penaltyPulse 1s infinite; }
    @keyframes penaltyPulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.1)} }
    .penalty-title { font-family:'Amatic SC',cursive; font-size:2.5rem; color:#ff4444; }
    .penalty-timer { font-family:'Secular One',sans-serif; font-size:3rem; color:#ff6666; margin:15px 0; }
    .penalty-text { font-size:0.95rem; color:rgba(255,200,200,0.7); max-width:300px; text-align:center; }

    .screen-shake { animation: screenShake 0.6s ease-out; }
    @keyframes screenShake {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-8px); } 20% { transform: translateX(8px); }
      30% { transform: translateX(-6px); } 40% { transform: translateX(6px); }
      50% { transform: translateX(-4px); } 60% { transform: translateX(4px); }
    }

    @media (max-width: 600px) {
      .fragments-grid { grid-template-columns: repeat(4, 1fr); gap: 4px; }
      .scroll-fragment { padding: 10px 4px; min-height: 60px; font-size: 0.75rem; }
      .verse-assembly { font-size: 0.9rem; }
    }
  </style>
</head>
<body class="theme-sea">

  <!-- Video Background -->
  <video class="video-bg" autoplay muted loop playsinline
    poster="https://images.unsplash.com/photo-1505118380757-91f5f5632de0?w=1920&q=80">
    <source src="https://cdn.coverr.co/videos/coverr-waves-crashing-on-rocks-2764/1080p.mp4" type="video/mp4">
  </video>
  <div class="fog-overlay"></div>
  <div class="dark-overlay"></div>
  <canvas id="particles-canvas"></canvas>

  <!-- Timer Bar -->
  <div class="timer-bar">
    <span class="room-indicator">ğŸŒŠ ×—×“×¨ 2 â€” ×§×¨×™×¢×ª ×™× ×¡×•×£</span>
    <span class="timer-display" id="timer-display">00:00</span>
  </div>

  <!-- Main Content -->
  <div class="room-container">
    <div class="room-icon">ğŸŒŠ</div>
    <h1 class="room-title">×§×¨×™×¢×ª ×™× ×¡×•×£</h1>
    <p class="room-subtitle">×”×™× ×¡×•×¢×¨. ×¤×¨×¢×” ×¨×•×“×£. ××¦× ××ª ×”×¤×¡×•×§ ×”× ×›×•×Ÿ.</p>

    <div class="question-box">
      <p class="question-text">×›××” ×¨×›×‘ ×‘×—×•×¨ ×œ×§×— ×¤×¨×¢×” ×œ×¨×“×•×£ ××—×¨×™ ×‘× ×™ ×™×©×¨××œ?</p>
      <p style="font-size: 0.85rem; color: rgba(0,191,255,0.5); margin-top: 8px;">
        ğŸŒŠ 8 ×§×˜×¢×™ ××’×™×œ×” × ××¦××• ×‘×™×. ×¨×§ 5 ××”× ××”×¤×¡×•×§ ×”×××™×ª×™. 3 ××–×•×™×¤×™×!
      </p>
    </div>

    <!-- Lives -->
    <div class="lives-bar">
      <span class="lives-label">×—×™×™×:</span>
      <span class="heart" id="heart-1">â¤ï¸</span>
      <span class="heart" id="heart-2">â¤ï¸</span>
      <span class="heart" id="heart-3">â¤ï¸</span>
    </div>

    <!-- Sea Canvas -->
    <div class="sea-scene">
      <canvas id="sea-canvas"></canvas>
      <div class="sea-label" id="sea-label">ğŸŒŠ ×”×™× ×¡×•×¢×¨... ×‘×—×¨ ××ª ×”×§×˜×¢×™× ×”× ×›×•× ×™×</div>
    </div>

    <!-- Fragments grid (shuffled by JS) -->
    <p style="font-size:0.85rem; color:rgba(0,191,255,0.5); text-align:center; margin-bottom:10px;">
      ğŸ“œ ×œ×—×¥ ×¢×œ ×§×˜×¢×™ ×”×¤×¡×•×§ ×”×××™×ª×™×™× â€” ×”×™×–×”×¨ ××”××–×•×™×¤×™×!
    </p>
    <div class="fragments-grid" id="fragments-grid">
      <!-- Inserted by JS -->
    </div>

    <!-- Verse assembly -->
    <div class="verse-assembly">
      <span class="fragment-slot" id="slot-0">___</span>
      <span class="fragment-slot" id="slot-1">___</span>
      <span class="fragment-slot" id="slot-2">___</span>
      <span class="fragment-slot" id="slot-3">___</span>
      <span class="fragment-slot" id="slot-4">___</span>
    </div>

    <div class="reveal-counter">
      ××¦××ª <span class="count" id="found-count">0</span> ××ª×•×š 5 ×§×˜×¢×™× ×××™×ª×™×™×
    </div>

    <!-- Google Maps -->
    <div class="map-container">
      <iframe src="https://maps.google.com/maps?q=29.5,32.5&t=k&z=8&output=embed&hl=he"
        loading="lazy" allowfullscreen style="height: 200px;"></iframe>
      <div class="map-caption">ğŸ“ ×™× ×¡×•×£ â€” ×›××Ÿ × ×§×¨×¢ ×”×™× ×œ×©× ×™×™×</div>
    </div>

    <!-- Sefaria -->
    <a href="https://www.sefaria.org/Exodus.14.7?lang=he" target="_blank" class="sefaria-link" style="margin:5px auto; display:inline-flex;">
      ğŸ“– ×©××•×ª ×™×´×“:×–×³ â€” ×¡×¤×¨×™×
    </a>

    <div class="password-section">
      <div class="password-wrapper">
        <input type="text" class="password-input" placeholder="×›××” ×¨×›×‘?..." autocomplete="off">
        <button class="submit-btn">ğŸ”“ ×¤×ª×—</button>
      </div>
      <div class="attempts-display"></div>
      <div class="hint-box">ğŸ’¡ ××¦× ××ª 5 ×”×§×˜×¢×™× ×”×××™×ª×™×™×. ×”××¡×¤×¨ ××•×¤×™×¢ ×‘×¤×¡×•×§.</div>
      <div class="hint-box strong">ğŸ”¥ ×©×© ×××•×ª. ×›××” ×–×” ×‘×¡×¤×¨×•×ª?</div>
    </div>
  </div>

  <div class="red-flash"></div>

  <div class="success-overlay">
    <div class="success-message">ğŸŒŠ ×”×™× × ×§×¨×¢!</div>
    <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px; font-size: 1.1rem;">×¢×‘×¨×ª ×‘×ª×•×š ×”×™× ×‘×™×‘×©×”. ××‘×œ ×”×¨ ×¡×™× ×™ ××—×›×”.</p>
    <a href="room3.html" class="next-room-btn">â†’ ××œ ×”×¨ ×¡×™× ×™ â›°ï¸</a>
  </div>

  <!-- Penalty overlay -->
  <div class="penalty-overlay" id="penalty-screen">
    <div class="penalty-icon">ğŸ’€</div>
    <div class="penalty-title">×¢×•× ×© 15 ×©× ×™×•×ª!</div>
    <div class="penalty-timer" id="penalty-countdown">15</div>
    <div class="penalty-text">3 ×˜×¢×•×™×•×ª. ×—×›×” 15 ×©× ×™×•×ª â€” ×”×–××Ÿ ×××©×™×š ×œ×¨×•×¥!</div>
  </div>

  <!-- Scripts -->
  <script src="particles.js"></script>
  <script src="game.js"></script>
  <script>
    // â”€â”€â”€ GAME INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!checkRoomAccess(2)) throw 'Access denied';
    new ParticleEngine('particles-canvas', 'water');
    const timer = new GameTimer();
    const checker = new PasswordChecker('room2', 'room3.html');

    // â”€â”€â”€ FRAGMENT DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const realFragments = [
      { text: '×•×™×§×—', slotIndex: 0 },
      { text: '×©×© ×××•×ª', slotIndex: 1, highlight: true },
      { text: '×¨×›×‘', slotIndex: 2 },
      { text: '×‘×—×•×¨', slotIndex: 3 },
      { text: '×•×›×œ ×¨×›×‘ ××¦×¨×™×', slotIndex: 4 }
    ];
    const fakeFragments = [
      { text: '×•×™×¡×¢ ×¤×¨×¢×”' },
      { text: '×‘×—×™×œ ×’×“×•×œ' },
      { text: '××¨×›×‘×•×ª ×–×”×‘' }
    ];

    // Combine and shuffle
    const allFragments = [
      ...realFragments.map(f => ({...f, isReal: true})),
      ...fakeFragments.map(f => ({...f, isReal: false}))
    ];
    for (let i = allFragments.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allFragments[i], allFragments[j]] = [allFragments[j], allFragments[i]];
    }

    // Render fragments into grid
    const fragmentsGrid = document.getElementById('fragments-grid');
    allFragments.forEach(frag => {
      const el = document.createElement('div');
      el.className = 'scroll-fragment';
      el.textContent = frag.text;
      el.addEventListener('click', () => pickFragment(el, frag));
      fragmentsGrid.appendChild(el);
    });

    // â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let foundCount = 0;
    let lives = 3;
    let penalized = false;
    let seaSplit = false;
    let splitProgress = 0;

    // â”€â”€â”€ FRAGMENT PICK LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function pickFragment(el, frag) {
      if (el.classList.contains('picked') || penalized) return;
      el.classList.add('picked');

      if (frag.isReal) {
        // â”€â”€ CORRECT â”€â”€
        el.classList.add('correct-pick');
        foundCount++;
        document.getElementById('found-count').textContent = foundCount;

        // Fill verse slot
        const slot = document.getElementById('slot-' + frag.slotIndex);
        slot.textContent = frag.text;
        slot.classList.add('filled');
        if (frag.highlight) slot.classList.add('highlight');

        // Progressive sea split
        splitProgress = foundCount / 5;
        if (foundCount >= 3) seaSplit = true;

        // Update sea label progressively
        if (foundCount < 5) {
          const labels = [
            'ğŸŒŠ ×”×™× ×¡×•×¢×¨... ×‘×—×¨ ××ª ×”×§×˜×¢×™× ×”× ×›×•× ×™×',
            'ğŸŒŠ ×”×’×œ×™× ××ª×—×™×œ×™× ×œ×–×•×–...',
            'ğŸŒŠ ×”×™× × ×¤×ª×— ×œ××˜...',
            'ğŸŒŠ ×›××¢×˜ ×©×! ×¢×•×“ ×§×˜×¢ ××—×“...'
          ];
          document.getElementById('sea-label').textContent = labels[Math.min(foundCount, labels.length - 1)];
        }

        if (foundCount === 5) {
          seaSplit = true;
          splitProgress = 1;
          document.getElementById('sea-label').textContent = 'âœ¨ ×”×™× × ×§×¨×¢! ×”×›× ×¡ ××ª ×”××¡×¤×¨ ×œ××˜×”';
          setTimeout(() => document.querySelector('.password-input').focus(), 800);
        }
      } else {
        // â”€â”€ FAKE - lose a life â”€â”€
        el.classList.add('wrong-pick');
        document.body.classList.add('screen-shake');
        const flash = document.querySelector('.red-flash');
        flash.classList.remove('active');
        void flash.offsetWidth;
        flash.classList.add('active');
        setTimeout(() => document.body.classList.remove('screen-shake'), 600);

        const heart = document.getElementById('heart-' + lives);
        if (heart) {
          heart.classList.add('breaking');
          setTimeout(() => heart.classList.add('lost'), 500);
        }
        lives--;

        // Track error in game storage
        const errors = parseInt(localStorage.getItem(GAME.STORAGE_PREFIX + 'Errors') || '0') + 1;
        localStorage.setItem(GAME.STORAGE_PREFIX + 'Errors', errors.toString());

        // All 3 lives lost â€” penalty
        if (lives <= 0) startPenalty();
      }
    }

    // â”€â”€â”€ PENALTY (15 sec wait, lives reset, fakes reset) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startPenalty() {
      penalized = true;
      document.getElementById('penalty-screen').classList.add('active');
      let countdown = 15;
      const el = document.getElementById('penalty-countdown');
      el.textContent = countdown;

      const interval = setInterval(() => {
        countdown--;
        el.textContent = countdown;
        if (countdown <= 0) {
          clearInterval(interval);
          document.getElementById('penalty-screen').classList.remove('active');
          penalized = false;
          lives = 3;
          // Restore hearts
          for (let i = 1; i <= 3; i++) {
            const h = document.getElementById('heart-' + i);
            h.classList.remove('lost', 'breaking');
          }
          // Reset fake fragments so player can try again
          document.querySelectorAll('.scroll-fragment.wrong-pick').forEach(frag => {
            frag.classList.remove('picked', 'wrong-pick');
          });
        }
      }, 1000);
    }

    // â”€â”€â”€ SEA CANVAS ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const seaCanvas = document.getElementById('sea-canvas');
    const seaCtx = seaCanvas.getContext('2d');

    function initSea() {
      seaCanvas.width = seaCanvas.parentElement.clientWidth;
      seaCanvas.height = 180;
      let time = 0;

      function drawSea() {
        time += 0.02;

        // Animate split progress smoothly
        if (seaSplit && splitProgress < 1) {
          splitProgress = Math.min(1, splitProgress + 0.012);
        }

        seaCtx.clearRect(0, 0, seaCanvas.width, seaCanvas.height);

        // Water gradient â€” shifts to lighter/brighter as sea splits
        const grad = seaCtx.createLinearGradient(0, 0, 0, seaCanvas.height);
        grad.addColorStop(0, `rgba(0,${40 + splitProgress * 60},${80 + splitProgress * 80},0.8)`);
        grad.addColorStop(1, `rgba(0,${20 + splitProgress * 30},${60 + splitProgress * 60},0.9)`);
        seaCtx.fillStyle = grad;
        seaCtx.fillRect(0, 0, seaCanvas.width, seaCanvas.height);

        // Dry path between walls of water (widens with splitProgress)
        if (splitProgress > 0) {
          const pathWidth = splitProgress * 80;
          const pathX = seaCanvas.width / 2 - pathWidth / 2;

          // Sand / dry ground
          const pathGrad = seaCtx.createLinearGradient(0, 60, 0, seaCanvas.height);
          pathGrad.addColorStop(0, `rgba(210,180,100,${splitProgress * 0.7})`);
          pathGrad.addColorStop(1, `rgba(180,150,80,${splitProgress * 0.5})`);
          seaCtx.fillStyle = pathGrad;
          seaCtx.fillRect(pathX, 60, pathWidth, seaCanvas.height - 60);

          // Glowing path center line
          if (splitProgress > 0.5) {
            const glow = seaCtx.createLinearGradient(0, 80, 0, seaCanvas.height);
            glow.addColorStop(0, `rgba(255,220,100,${(splitProgress - 0.5) * 0.6})`);
            glow.addColorStop(1, 'rgba(255,180,50,0)');
            seaCtx.fillStyle = glow;
            seaCtx.fillRect(seaCanvas.width / 2 - 4, 60, 8, seaCanvas.height - 60);
          }
        }

        // Waves â€” left half and right half separate as splitProgress grows
        for (let layer = 0; layer < 3; layer++) {
          const pathHalfWidth = splitProgress * 40 + layer * 10;

          // Left wave wall
          seaCtx.beginPath();
          seaCtx.moveTo(0, seaCanvas.height);
          for (let x = 0; x <= seaCanvas.width / 2 - pathHalfWidth; x += 5) {
            const y = 40 + layer * 25
              + Math.sin(x * 0.02 + time + layer) * 15
              + Math.sin(x * 0.01 + time * 0.7) * 10;
            seaCtx.lineTo(x, y);
          }
          // Wall of water edge â€” rises up when splitting
          const wallHeight = 40 + layer * 25 - splitProgress * 30;
          seaCtx.lineTo(seaCanvas.width / 2 - pathHalfWidth, wallHeight);
          seaCtx.lineTo(seaCanvas.width / 2 - pathHalfWidth, seaCanvas.height);
          seaCtx.closePath();

          const waveColors = [
            `rgba(0,${100 + splitProgress * 40},200,0.5)`,
            `rgba(0,${80 + splitProgress * 30},180,0.4)`,
            `rgba(0,${60 + splitProgress * 20},150,0.3)`
          ];
          seaCtx.fillStyle = waveColors[layer];
          seaCtx.fill();

          // Right wave wall (mirror)
          seaCtx.beginPath();
          seaCtx.moveTo(seaCanvas.width, seaCanvas.height);
          for (let x = seaCanvas.width; x >= seaCanvas.width / 2 + pathHalfWidth; x -= 5) {
            const y = 40 + layer * 25
              + Math.sin(x * 0.02 - time + layer) * 15
              + Math.sin(x * 0.01 - time * 0.7) * 10;
            seaCtx.lineTo(x, y);
          }
          seaCtx.lineTo(seaCanvas.width / 2 + pathHalfWidth, wallHeight);
          seaCtx.lineTo(seaCanvas.width / 2 + pathHalfWidth, seaCanvas.height);
          seaCtx.closePath();
          seaCtx.fillStyle = waveColors[layer];
          seaCtx.fill();
        }

        // Foam on wave crests (only when not fully split)
        if (splitProgress < 0.8) {
          for (let x = 0; x < seaCanvas.width; x += 30) {
            // Skip the path gap
            if (Math.abs(x - seaCanvas.width / 2) < splitProgress * 40) continue;
            const y = 40 + Math.sin(x * 0.02 + time) * 15;
            seaCtx.globalAlpha = (0.3 + Math.sin(time + x) * 0.2) * (1 - splitProgress * 0.8);
            seaCtx.fillStyle = '#fff';
            seaCtx.beginPath();
            seaCtx.arc(x, y, 2, 0, Math.PI * 2);
            seaCtx.fill();
          }
          seaCtx.globalAlpha = 1;
        }

        // Spray / mist at the water walls when splitting
        if (splitProgress > 0.2) {
          const wallX1 = seaCanvas.width / 2 - splitProgress * 40;
          const wallX2 = seaCanvas.width / 2 + splitProgress * 40;
          for (let i = 0; i < 8; i++) {
            const sprayY = 40 + Math.random() * 60;
            const alpha = (splitProgress - 0.2) * 0.4;
            seaCtx.globalAlpha = alpha;
            seaCtx.fillStyle = '#aaddff';
            seaCtx.beginPath();
            seaCtx.arc(wallX1 + Math.random() * 8 - 4, sprayY, 1.5, 0, Math.PI * 2);
            seaCtx.fill();
            seaCtx.beginPath();
            seaCtx.arc(wallX2 + Math.random() * 8 - 4, sprayY, 1.5, 0, Math.PI * 2);
            seaCtx.fill();
          }
          seaCtx.globalAlpha = 1;
        }

        // Israelites walking through when fully split
        if (splitProgress > 0.85) {
          const alpha = (splitProgress - 0.85) / 0.15;
          seaCtx.globalAlpha = alpha;
          seaCtx.font = '14px serif';
          seaCtx.textAlign = 'center';
          // Draw small figures walking through the path
          const figurePositions = [0.2, 0.4, 0.6, 0.8];
          figurePositions.forEach(pos => {
            const fx = seaCanvas.width / 2;
            const fy = 80 + pos * (seaCanvas.height - 90);
            seaCtx.fillText('\uD83D\uDEB6', fx - 10, fy);
            seaCtx.fillText('\uD83D\uDEB6', fx + 6, fy + 5);
          });
          seaCtx.globalAlpha = 1;
          seaCtx.textAlign = 'start';
        }

        requestAnimationFrame(drawSea);
      }

      drawSea();
    }

    initSea();
    window.addEventListener('resize', initSea);
  </script>

</body>
</html>
